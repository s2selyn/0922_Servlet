package com.kh.first.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

// ??? 개발자가 구현해야 할 것들을 추상메소드로 제공해준다
// 매핑값은 서블릿마다 고유한 값이어야함
@WebServlet("/get.do") // 앞에서 내가 쓴것과 맞는지 확인, 잘못되었다면 여기서 수정해도 된다.
public class RequestGetServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	// 이건 서블릿 버전 관리용
       
    public RequestGetServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		/*
		 * 톰캣 실행 -> web.xml 파싱(배포서술자부터 파싱해서 해석함)
		 * 찾아서 리스닝 상태, 듣고있는 상태, 요청이 올 때 까지, 서버니까!(소켓 프로그래밍 했던거 기억)
		 * 
		 * 클라이언트(사용자)가 뭘로 요청? 브라우저에서 URL로 요청
		 * 서블릿을 많이 만들건데 각 서블릿에 매핑값을 달아놓을것임
		 * 어떤 URL이 오면 어떤 서블릿이 동작할지 각 서블릿을 매핑할것임
		 * 
		 * 테스트 서블릿을 기존의 매핑값과 동일하게 만든다면? 서버 실행부터 터져버림 -> LifecycleException
		 * 서블릿도 클래스라서 생명주기가 있음, 서블릿 클래스로 생성자 호출해서 서블릿 객체가 되어야 서블릿이 가진 메소드를 호출해서 사용가능
		 * 서블릿이 컨트롤러라고 가정하면 뷰에서 직접 생성자 작성해서 동작시켰지만
		 * 이제 서블릿은 개발자가 직접하지 않고 톰캣(서블릿 컨테이너)이 관리한다, 서블릿 생명주기는 톰캣이 관리한다는 뜻
		 * 사유도 잘 알려줌, 두 서블릿들 모두 url-pattern 이 같은 것에 매핑되어 있는데, 이는 허용되지 않습니다. 라고 친절하게 알려줌
		 * 요청받는 입장에서 어떤걸 객체로 만들어야하는지 알수없으니 서버자체가 실행되지 못함
		 * 그러므로 각 서블릿은 매핑값이 고유해야한다
		 * 
		 * 서블릿을 명세 라고도 표현한다, 서블릿은 사실 우리가 만드는 클래스라기보다 이친구에게 상속해주는 위쪽의 인터페이스를 의미함
		 * 서블릿 인터페이스는 추상 메소드를 가지고 있음, 걔네 얘기를 해보자
		 * 
		 * init() (initialize) => service() => doGet()/doPost() => destroy()
		 * 서블릿 생명주기 / 싱글톤 패턴으로 객체 하나만을 사용 / 톰캣이 멀티스레드 처리(스레드풀)
		 * 이 메소드들은 서블릿의 생명주기와 관련되어있음
		 * 
		 * 서블릿을 만들어서 구현할텐데, 옛날에는 이 메소드들을 직접 상속해서 오버라이딩해서 동작시켜야했음
		 * 개발자들이 공통적으로 작업할 때 다른 상황들, 코드, 처리방식이 생기니 만들때는 문제가 없는데
		 * 유지보수할때 문제가 생겨버려서 통일성을 갖출 필요성이 느껴짐
		 * 
		 * 서블릿은 톰캣이 생성하고 관리하는데, 처음 서버를 켤때는 톰캣이 자신의 서블릿 컨테이너 공간(메모리임)에 서블릿을 모셔놓는다
		 * 그러다가 누군가 서블릿 매핑값으로 요청을 하면, 요청을 처리할 서블릿 클래스를 로딩해와서 생성자로 객체를 만들어올림
		 * 그러면서 init() 메소드를 호출한다, 인스턴스 생성을 하면서 init() 호출
		 * 그 뒤로는 요청이 올때마다(처음 요청받아서 올라가면 지우지않고 계속씀, 서버가 꺼질때까지, 우리가 뷰에서 컨트롤러 생성해서 계속 쓰듯이)
		 * ??? 9:21 서비스안에서 doGet, doPost 메소드 호출함, 요청 방식에 따라 메소드 호출
		 * 나중에 서버 종료하면 destroy 메소드 호출하고 객체 ㅂㅂ
		 * 
		 * 서블릿은 싱글톤 패턴을 이용해서 요청이 오면 객체를 딱 하나만 만들어둔다, 요청마다 생성하는게 아니라
		 * 기존에 만든 객체를 이용해서 호출함
		 * 객체가 하나라면 여러 클라이언트의 동시 요청 처리가 힘들다, 그렇지만 그건 톰캣이 알아서 해줌, 신경안써도됨
		 * 
		 */
		
		// 이 파트에서 작업하면 되는데 오늘 시간없어서 출력문 하나만 써보자
		// System.out.println("헉 진짜임?");
		// get 방식 요청으로 이게 출력되는걸 어제 확인했음
		
		// 실제로 서블릿 만들면 doGet, doPost만 만들어서 진행한다, 통일성이 부여된 것
		// 이 안에서 작업을 수행하면 되는데...
		// 혹시나 이 서블릿을 생성될때/소멸될때 뭔가를 해야한다면 init, destroy를 오버라이딩해서 구현해서 작업한다
		
		/*
		 * (당분간) Dynamic WebProject진행 시 Servlet을 Controller로 사용
		 * 
		 * 컨트롤러 하는 일이 뭐였나요?
		 * 1. 데이터 가공
		 * 2. 요청 처리(Service호출)
		 * 3. 결과값 반환(응답화면지정) -> 이건 이후에 배우게 될 버전에 맞춰서 작업을 했다, 아직 여기서 진화를 두번 더 해야함
		 * DynamicWebProject -> ? -> ?
		 * 결과값 반환은 최종진화버전에 맞춰서 수업을 했음
		 * 당분간은 응답화면지정작업을 해줘야함, 어떤 응답화면을 돌려줄지. 근데 이건 좀이따 천천히 얘기하고
		 * 
		 * View에서 Get방식으로 요청 시 doGet()가 호출됨!!
		 * 
		 */
		
		// System.out.println("GET방식으로 호출됨!!");
		// 테스트용 출력문 작성하고 서버 실행
		// 어제 폼태그 눌러서 갔지만 url만 잘 적으면 이 서블릿은 잘 동작한다, 무조건 폼태그로만 요청을 보낼 수 있는 것은 아님
		// 주소입력창에 적어서 요청보내는건 항상 get방식이다.
		// http://127.0.0.1:4000/first/get.do 이렇게 요청을 보내면 서블릿이 요청을 받아서 우리가 써놓은 코드를 동작시킴
		// 또는 http://localhost:4000/first/get.do 으로 작성해도 된다, 호스트 파일에 적혀있음, 이게 좀 더 편하긴 해
		// 어제 만든 웰컴페이지에서 요청 보내보면 url에 전부 사용자가 입력한(요청한)값이 붙어서 요청된다
		// 만약에 insert 요청이었다면? 요청 시 전달값이 6개 생기는거겠지
		// 서블릿에서 어떤 작업을 해야하나? 요청 시 넘어오는 값을 여기에서 뽑아서 가공하는 작업을 해줘야함! 얘가 컨트롤러 역할을 할테니까
		
		// get 방식 요청을 받을거라 doGet 메소드에서 작업하고 있음, 매개변수 두개가 있다
		// HttpServletRequest, HttpServletResponse 각각 요청 / 응답
		// 메소드 매개변수 두개라는건 톰캣이 이 메소드를 호출하면서 인자값을 전달했다는 얘기
		// 자바는 인자값 전달하지 않으면 메소드 호출이 불가능하니까 이건 100% 넘어왔다는 이야기가 된다
		// 그럼 얘네 정체가 뭐야? 뭐가들었어?
		/*
		 * 인자값으로 두 개 넘어옴
		 * 
		 * 첫 번째 매개변수 HttpServletRequest 타입에는 요청 시 전달된 내용들이 담김
		 * => 요청 전송 방식, 요청 URL, 요청한 사용자의 정보, 사용자가 input요소에 입력한 값 등...
		 * Request는 요청이니까, 요청할때의 프로토콜, 사용자의 물리적 주소, 어떤 경로를 통해서 요청을 보냈는지도 들어있다
		 * 
		 * 두 번째 매개변수 HttpServletResponse 타입은 요청 처리 후 응답할 때 사용하는 객체
		 * 서블릿을 처음 만들어서 해보는거니까 둘 다 알차게 써봅시다
		 * 
		 * 요청 처리 스텝
		 * 
		 * 1. 우선 요청을 처리하기 위해서 요청 시 전달된 값(사용자가 입력한값)들을 뽑는다.
		 * => key-value세트로 담겨있음(name속성값=value속성값)
		 * 사용자가 넘긴 값은 무슨 형태로 앞에서 뒤로 넘기나요? key-value의 형태로 넘긴다, 여기에서도 이걸 k-v 형태로 빼와야함
		 * => request의 Parameter라는 곳에서 전달값을 뽑아내야함
		 * 이건 Request에서 뽑는다, 요청할 때 들어오는 값이니까
		 * 
		 * 2. 뽑아낸 값을 가공해서 요청 처리를 진행해야함(Service -> DAO -> DB 갔다와서 응답돌려주는 그런 형태와 느낌이겠지)
		 * 
		 * 컨트롤러는 다시 서비스에서 뭔가 반환받을텐데, 처리 결과에 따라서 성공실패 페이지를 응답해줄것임
		 * 지금 뭔가 다 처리됐다고 가정하고 실패도 없다고 100% 성공으로 가정하고 입력한게 맞니? 하고 확인할 페이지 만들자
		 * 3. 처리결과에 따른 성공 / 실패 페이지 응답
		 * 
		 */
		
		/*
		 * request의 parameter영역으로부터 전달된 데이터 값을 뽑아내는 방법
		 * 
		 * request에게 내놔 해야지, 우리 늘 하던거, 다양한게 넘어오니까 인자값으로 key
		 * - request.getParameter("키값") : String(input요소에 적어놓은 name속성값) (100% String으로 돌아온다 메소드 반환타입 정해져있으니까)
		 * => 반환형이 String이기 때문에 다른 자료형으로 사용해야 한다면 개발자가 알아서 Parsing해야함
		 * 
		 * 체크박스같은건 여러 선택지를 주고 여러개 선택하게 하는건데, name 속성값이 하나만 넘어가는게 아니라 동일한 name 속성값으로 여러 value가 넘어간다
		 * request.getParameter로 뽑아봤자 하나만 나오니까 다른 메소드를 호출해서 써야함
		 * 여러개의 값을 뽑아내니까 반환형이 배열
		 * - request.getParameterValues("키값") : String[]
		 * => 하나의 key값으로 여러 개의 value들을 받아야 할 경우
		 * 지금은 체크박스, 항상 그런건 아니고 여러 상황이 있을 수 있지만 아무튼 지금은 체크박스
		 * 
		 * 뽑아서 출력해보고 실제 입력값이 서블릿으로 잘 들어오는지 확인해보자
		 * 이거 할 때 잘 알아야하는건 input요소의 name 속성값, key값이 어떻게 넘어오는지 생각해야함
		 * 
		 */
		
		// 1단계. 값 뽑기
		// map이라고 좀더 편한게 있는데 지금 학습용도
		// 인자값으로 앞단에서 적은 name 속성값(value값, 실제 URL에 찍히는거)
		String name = request.getParameter("name");
		// 반환타입은 항상 String이다.
		
		// 본격적으로 개발자다운 생각해야함
		// name 변수에 값이 들어올것임, 앞에서 JS로 정규표현식 배웠기 때문에 걸러서 오긴 하겠지
		// 일단 출력하고 이야기 계속
		System.out.println(name);
		// 자바소스코드 변경되면 컴파일 다시해야하니까 톰캣 서버 재시작 해야함
		// input요소에 입력한 값이 콘솔에 잘 출력된다
		// name 변수, String 리터럴값에 어떤 값들이 들어올 수 있을까? 경우의 수를 생각해야 한다.
		// "셀 수 없음", 얘는 문자열, 경우의 수를 생각해봤을때 사용자가 무슨 문자열을 입력할지 모른다
		// 만약에 maxlength="5"로 작성하고 정규표현식을 써서 5글자 이상은 요청을 못보내게 막았다면?
		// 그럼 개발자가 무조건 5글자 이내의 문자열만 들어오겠네? 라고 생각할거임
		// 실제로 5글자 넘어가면 데이터를 넘길 수 없다, get방식은 주소창에 url을 입력해서 전달하니까 정규표현식 무시하고 주소창에 써버리면 프론트에서 막을 수 없음
		// 절대못막지요, 기본적으로 앞단에 해두는 이유는 개발자가 유효성 검증을 명확히 하겠다기보다는 사용자의 편의를 위한것, 웹사이트 이용하는 사용자의 편의성 높이기
		// 실제로 넘어오는 값의 검증은 뒤에서 해야한다, 두번씩 해야하게됨
		// 앞쪽은 사용자 편의를 위해서가 목적이고, 악의적인 사용자들이 넘기는 값은 뒤에서도 값의 검증을 해줘야겠지
		// 그래서 기본적으로는 셀 수 없음이 정답
		// 그나마 경우의 수를 줄여본다면?
		// "홍길동" / ""(텍스트상자가 비어있을 경우 빈문자열) / null
		// 1. 사용자가 정상적인 값을 입력했을 경우("홍길동" 등)
		// 2. 인풋에 적어놓은게 아니라 아무것도 입력안하고 요청을 보낼 수 있음(빈 문자열)
		// 3. get방식이니까 url에서 name을 지워버릴수도 있음, 이렇게 요청을 보내면 null이 출력된다
		// 이게 insert라고 가정하면 이런것들 들고 DB가야하는데, 컬럼에 not null 제약조건이 붙어있으면 이건 insert 반드시 실패하는 값이므로 DB에 애초에 갈필요가 없다
		// 이런것들을 개발자가 들어올 수 있는 값의 경우의 수를 생각해서 DB에 넘길 값을 체크해줘야해
		// ??? 10:13 절차와 과정들을 생각, 우리에게 중요한 것들
		// 방법은 또 바뀌는거고, 사용자가 앞에서 넘길 값은 안바뀌겠지? 여기에 focus
		
		String gender = request.getParameter("gender");
		System.out.println(gender);
		// gender 키값으로 값이 넘어온다, 값의 경우의 수는?
		// "남" / "여" / "선택 안 함" / null
		// 체크박스는 checked가 되어야 실제 요청 시 key값에 포함된다
		// checked 상태가 안되면 요청 시 값이 넘어가지 않는다, 이러면 null값이 들어옴
		// ??? 10:16 그럼 또 컬럼에 not null이면 insert에 문제가 생기니 제약조건을 걸든 추가작업?을 해줘야함
		
		int age = Integer.parseInt(request.getParameter("age"));
		// input요소 타입이 number니까 애초에 number가 아니면 요청이 안보내진다
		// number가 넘어오겠다, 생각 가정하고 작업을 해보자
		// 그럼 일반적으로 정수형 값을 다룰 때는 자바에서 int형 변수로, 근데 오른쪽 반환타입이 String임, 담을 수 없음
		// 이걸 정수형태로 변환해주려면 파싱을 추가적으로 작업해줘야함
		// Wrapper클래스를 이용해서 파싱
		System.out.println(age);
		// "14" / ""
		// ??? 10:20 아무것도 입력안해도 넘길 수 있음, 폼태그 안에서 key가 넘어가게 되니까 아무것도 입력안하면?
		// ??? 널은 키값 못찾을때 나오는게 널, 구분해야한다
		// 빈 문자열이 넘어가면 빈 문자열을 정수로 바꿀(파싱할)수는 없음
		// "" : NumberFormatException이 발생
		
		// 들어올수있는 값의 경우의 수를 생각 안하면 여기저기서 에러 팡팡
		// 이것에 대해서 각 예외상황에 대한 예외처리를 잘 해줘야함, 그래야 개발 잘하는거겠지
		
		String city = request.getParameter("city");
		System.out.println(city);
		// 일반적인 사용자로 가정하면 들어올 수 있는 값의 경우의 수는 두개뿐
		// 가장 위의 옵션으로 selected된 상태, 나쁜의도로 고치지 않는 이상 들어올 값은 서울 또는 제주도뿐
		// "서울" / "제주도"
		
		double height = Double.parseDouble(request.getParameter("height"));
		System.out.println(height);
		// 이것도 기본값이 selected 되어있는거나 마찬가지, 값이 없을수는 없음
		// 생각해보니 어차피 정수값만 들어오니까 굳이 double?
		// 자바 복습도 같이하는거지뭐, double을 다시 int로 바꾸려면?
		// double이 int에 들어갈 수 없는건 자료형이 다르기 때문이죠, 강제 형변환 해줘야함
		int realHeight = (int)height;
		// 강제 형변환 시 주의(조심)할 점은? 소수점자리는 손실된다 매우 조심하세요
		// 아리안5 로켓 발사 할 때 64비트 부동 소수점 숫자 실수 자료형을 16비트 정수 자료형으로 변환하다가 로켓 펑
		// 1억 5천만 유로 ㅂㅂ.. 형변환하다가... 날려먹은것이에요...
		// 4에서 5로 올라간거니 어떻게 될 지 몰랐겠지만 아무튼 원인은 형변환 하다가 소수점 날려서
		// 까딱 잘못하다가는 로켓을 날려먹을수도 있는 코드가 됩니다 사람일 모르는거임
		
		// 마지막은 체크박스, 동일한 name 속성값이 여러개 넘어오는데, getParameter로는 제일 앞의 것만 하나 받기 때문에 다른 메소드
		String[] foods = request.getParameterValues("food");
		// System.out.println(foods); 배열의 toString이 출력됐지롱
		// 진화해라!!!!
		System.out.println(Arrays.toString(foods));
		// 체크박스는 선택의 영역, 선택을 안할수도 있겠지? 그럼 null이 넘어와버림
		// ["떡볶이", "초밥"] / null
		
		// 어제 에러 두개 구경했음
		// 자주보는 상태코드
		// 404 : 파일 또는 요청을 받아주는 서블릿을 찾지 못했을 때 발생하는 코드
		// 			=> 경로를 잘 못 적었거나 파일명에 오타가 났을 때
		// 우리 서블링 매핑값 get.do만 등록해뒀는데, 서버가 처리할 수 없는 매핑값이 들어오면 404, 처리해줄 자원이 없다는 뜻
		// 내가 스스로 코드짜서 개발하고있는데 404가 떴다면 내 생각과 뭔가 잘못되고 있다는거겠죠?
		// 경로를 잘못 적었거나 파일명에 오타를 낸거겠지. 서블릿 매핑값을 잘못, 경로잘못, a태그 파일명 잘못 등
		// 선생님 화면 그대로 복제하는게 아니라 내꺼 보고 어느부분을 어떻게 적는지를 생각해야함
		//
		// 500 : 자바 소스코드상의 오류(예외발생)
		// 예외처리 안해놨으니 얼른 가서 자바코드 고쳐라
		// 이제부터 본격적인 예외처리
		// 공부할때는 고치고 돌리고 이랬지만 웹에서는 사용자가 와 500이다 이러면 안된다고요
		// 서버에 문제가 생기더라도 사용자는 이걸 모르고 우회시켜서 딴짓하게 해줘야함, 멈춰버리면 안되게 처리 진행해주든가 애초부터 꼼꼼하게 해서 막든가
		// 근데 뭐 실제로 난리 많이 납니다, 대수롭지 않게 지나가서 그렇지
		// 이건 어떻게 보면 회사의 신뢰성과 관련된 이야기임
		// 자바스크립트 상에서 문제생기고 이런건 뭐 사소하고 개발자도구 열지않으면 모를수있지, 근데 500자체는 문제야...
		// 이거 자체를 근본적으로 막을 수는 없다, 예외발생 자체를 막는건 불가, 어떻게 할지는 예외처리를 try catch로 잘 묶어서 진행시켜!
		
		// 원래 컨트롤러에서 이런작업함, 데이터가 많은데 서비스에 넘길 때 객체만들었음
		// 2단계. 데이터가공
		// Person person = new Person(name, gender, age, city, height, foods);
		// 사실은 없지만 이런거 만들었다 침
		
		// 그럼 원래 그 다음단계는 요청처리
		// 3단계. 요청 처리(DB와의 상호작용 == JDBC/MyBatis 활용해서)
		// 보통의 일반적인 흐름 : Controller에서 Service의 메소드를 호출하면서 값(아마도 person)을 전달
		// -> DAO호출 -> DB SQL문(INSERT)문 실행 -> 정수형태의 결과값 반환
		// int result = new PersonService().savePerson(person);
		// 실제로 값을 받았으면 이런걸 했겠지? 했다고 쳐 바쁘니까
		
		// 4단계. 결과값 반환 or 응답화면 지정
		// 무조건 성공했다고 가정
		
		// 순수 servlet만 사용해서 응답데이터 넘기기(옛 개발자들의 노고)
		// 사용자에게 HTML + CSS + JS 응답
		// 어떤 형태로 만들거냐면
		/*
		 * 요청 처리에 성공했습니다!
		 * 
		 * XXX님은
		 * XX살이며,
		 * XXX에 삽니다.
		 * 키는 XXXcm이고
		 * 
		 * 성별은 case 1. 선택을 안했습니다.
		 * 		case 2. 남성입니다.
		 * 		case 3. 여성입니다.
		 * 
		 * 좋아하는 음식 case 1. 없습니다.
		 * 			  case 2. 치킨머시기~ 떡볶이~
		 * 
		 */
		
		// HttpServletResponse 객체를 이용하면 된다
		// 1단계) 응답 데이터 형식 지정 -> 문서형태의 HTML / 인코딩 방식 UTF-8
		// response객체에 있는 메소드 이용, 형식 지정(set)할거니까 set으로 시작하는 setContentType
		response.setContentType("text/html; charset=UTF-8");
		// ??? 11:05 돌아갈 파일이랑 인코딩을 써준다
		// charset인 이유 인코딩이라는 단어가 생각이 안나서 이렇게 만들었다네요
		// HTTP 1.0에서 1.1로 넘어갈 때 발견해버림, 근데 바꾸면 1.0으로 만든게 동작안하니까 그대로 뒀다네요
		
		// 2단계) 출력 스트림 생성(데이터 내보내야하니까)
		// 스트림 InputStream / OutputStream
		// 		  Reader	/  Writer
		// 출력해서 내보낼건데 한글이 껴있으니 writer
		PrintWriter pw = response.getWriter();
		// PrintWriter로 스트림 받음, 소켓통신할때 써본녀석임
		
		// 3단계) 스트림을 이용해서 HTML데이터 출력
		pw.println("<html>");
		pw.println("<head>");
			pw.println("<title>순수 서블릿으로 응답해보기</title>");
			pw.println("<style>");
			// head영역에서 id선택자로 style 태그 내부에 스타일 부여하기
			pw.println("#name{color : orange}");
			pw.println("#age{color : orangered}");
			pw.println("#city{color : forestgreen}");
			pw.println("#height{color : green}");
			pw.println("#gender{color : gold}");
			
			pw.println("</style>");
		pw.println("</head>");
		
		pw.println("<body>");
		
			pw.println("<h1>요청 처리에 성공했습니다.</h1>");
			
			// println 쓰면 여러줄, +로 문자열 연산하기 싫어서 printf(포맷) 사용해보기
			pw.printf("<span id='name'>%s</span>님은 <br>", name);
			pw.printf("<span id='age'>%d</span>살이며, <br>", age);
			pw.printf("<span id='city'>%s</span>에 삽니다.<br>", city);
			
			pw.printf("키는 <span id='height'>%.1f</span>cm이고 <br><br>", height);
			// 여기까지는 사용자가 값을 다 입력했다고 가정하면 입력한 내용 그대로 보내면 된다
			
			// 성별은 경우가 나뉜다, 각 선택에 따라 결과메세지가 달라짐
			// 자바에서는 이런 상황에 조건문을 쓸수밖에
			pw.print("성별은 ");
			if(gender == null || "선택안함".equals(gender)) { // 아예 key값이 안넘어와서 null
				// gender.equals 이러면 NPE 뜬다, 주의
				
				pw.println("선택을 안했습니다.");
				
			} else if(gender.equals("남")) {
				pw.println("<span id='gender'>남자</span>입니다.");
			} else {
				pw.println("<span id='gender'>여자</span>입니다.");
			}
			
			// food도 체크박스 안했을 수 있음, 체크안하면 null, null이 아니라면 뭐 하나는 골랐다는 의미고 -> null 일 때 아닐 때니까 조건문
			pw.print("좋아하는 음식은");
			if(foods == null) {
				pw.println("없습니다");
			} else { // 최소한 뭐 하나는 골랐다는건데 몇개일지는 모름, 선택한거 다 보여주고싶음 -> 반복문
				
				pw.println("<ul>");
				
				// 고른 요소만큼 반복문을 통해 li요소 생성
				for(int i = 0; i < foods.length; i++) {
					
					// 쌍따옴표 안의 따옴표 안의 쌍따옴표를 써야 하는 상황이 온다면?
					pw.printf("<li style='color:\"plum\"'>%s</li>", foods[i]);
					// 쌍따옴표 앞에 역슬래시를 추가하면 쌍따옴표로 인식되지 않고 쌍따옴표 문자로 인식된다.
					
				}
				
				pw.println("</ul>");
				pw.println("입니다.");
				
			}
		
		pw.println("<script>");
			pw.println("alert('축하해~~~');");
		pw.println("</script>");
			
		pw.println("</body>");
		pw.println("</html>");
		
		// 사용자의 입력값에 따라 달라지는 동적으로 만들어진 응답, 원래는 DB까지 갔다오는거지만 그건 생략했고
		// 결과적으로 사용자의 뷰에 보여줘야함, 이전엔 클래스의 콘솔에 출력해줬음
		// 뷰에서 볼 수 있는 형태의 데이터로 보여줘야하는데, 이런 문자열을 보내면 브라우저가 만들어서 화면에 띄워준다
		// 결국은 문자열 보내기. 실제로 보내는 데이터는 작성해서 보낸 소스코드(페이지 소스보기로 보이는거)
		// HTML, CSS, JS는 고정이고 그 안에 들어가는 값을 바꾸는 작업을 하겠지
		// 아무튼 초창기 개발자들은 이런식으로 작업
		// 자바 처음 만든 회사에서 서블릿을 만들었는데, 이 형태였다고 합니다. 이런식으로 문자열 스트림을 만들어서 보내서 화면을 만들도록함, 동적으로
		// 해보니까 끔찍하네요... 편하게 할 수 있는 기술이 있음
		// 지금은 자바 클래스 안에 html 문자열 넣은 구조인데, html 형태 안에 자바코드를 쓸 수 있는 기술을 또 만들어줌
		// html처럼 생겼지만 자바로 돌아가는 칭구
		// 다음부터는 이렇게 안만들고 좀더 편한방법으로 만들자
		// 지금한건 순수하게 불편하고, 응답데이터를 리터럴(하드코딩) 했기때문에 수정마다 서버 재부팅 해야하는게 불편해서
		// 새로운 기술 나와서 진화함, 그래도 한 2, 3년 정도 뒤에 나와서 3년간 웹개발자들은 이런일을..했네요.. 그당시 인기없었던 자바웹개발자의 이유였을지도
		
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}
